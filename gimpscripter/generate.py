#!/usr/bin/env python

'''
  Crux of generating a wrapping plugin.
  Generates another plugin (in Python language) that is a wrapping plugin to a target plugin.
  Shortcut means: 
  1) alias or link to target plugin
  2) possibly different settings dialog at wrapping plugin runtime:
    a) no dialog, use standard or current settings for target plugin.
    b) no dialog, use constant settings for target plugin (chosen at creation time)
    c) dialog of deferred parameters (deferred and defaulted at creation time.)

Copyright 2010  Lloyd Konneker

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
'''

'''
Terminology:

Wrapped versus wrapping, target versus wrapping plugin:
    This plugin: what you are reading now, that generates code.
    Wrapping plugin: plugin code generated by this plugin.
    Wrapped plugin: plugin that wrapping plugin calls, iow the target.

Formal versus actual parameters:
    Formal parameters are in a definition
    Actual parameters are in a call
    
Script-declared versus PDB-declared parameters:
    Script-declared: in "parameters" argument of a register() call
    PDB-declared: in paramdefs held by PDB
      and in formal parameters of a plugin_main()
    Hidden parameters: the difference, i.e. prefix of PDB-declared parameters
        e.g. "run-mode, image, drawable"
        that Pygimp gimpfu module hides from script authors.

Users:
  wrapping-user: a user of a plugin generated by GimpScripter
  author-user: a user of GimpScripter to create a plugin
  
Definitions: 

Settings versus options versus preferences:  all essentially the same thing.  
Gimp seems to use "settings" for plugins and "options" for tools.
In most GUI terminology, "options" or "preferences" is used.

Preset: define initial value of, but still allow changes.  Same as default.
Constant: not changeable by wrapping-user.  Changeable when you create a wrapping plugin, constant thereafter.
'''

'''
I tried to simply register an existing plugin under a new menu item.
It doesn't work, disallowed by GIMP, can only register menu at certain times in life of plugin, init etc.
gimp.pdb.gimp_plugin_menu_register("python_fu_impscriptor", "<Image>/Filters/Map/Foo");
'''

from gimpfu import *

import os
import stat
# import operator # for or_

# our own submodules
from gimpscripter import parameters 
from gimpscripter import constantmaps
from gimpscripter import parse_params
from gimpscripter import template
from gimpscripter import macros
from gimpscripter.mockmenu import plugindb
# Refers to a pdb dictionary of useable procedures ( a facsimile subset of the Gimp PDB.)




# Constants, at least in this version.
GIMPSCRIPTER_WRAP = "wrapper-"
GIMP_STD_FILENAME_PREFIX = "plugin-"
GIMP_STD_PROCEDURENAME_PREFIX = "python-fu-"
# Next version might let author-user chose menu path for wrapping plugin
# !!! Not have a trailing /
WRAPPING_MENU_PATH_PREFIX_REGISTER = "<Image>/Shortcuts"  # For registration, need <Image>
WRAPPING_MENU_PATH_PREFIX = "Shortcuts"


# Name of function to lookup object for an ephemeral by name.
# Parameters will be appended.
# Use "runtime.ephemera.lookup" if we are not putting  runtime directly in wrapping plugin
EPHEMERAL_LOOKUP = "ephemera.lookup"

# Lines of code to insert
# indent 2 spaces and trail newline !!!
# TODO unify names
INTER_COMMAND_RUNTIME = "  ephemera.update()\n" 
GIMPSCRIPTER_PRELUDE = "  ephemera = GimpEphemera(image, drawable)"  # WAS image_stack = GimpStack(image)\n"
GIMPSCRIPTER_POSTLUDE = ""
# !!! Note  call to image_stack.top() is in constantmaps.py

#  prefix to use before pdb procedure names.
#  gimp module creates a dictionary named pdb.
#  gimpfu module aliases gimp.pdb to pdb.
PDB_INVOKE_PREFIX = "pdb."

# TODO make  wrapping plugin return  stack top

# Constants for type of wrapping plugin.
# In  future, maybe other types eg sequences of plugins
WRAPPING_TYPE_CONSTANT = 1    # all settings constant i.e. hardcoded
WRAPPING_TYPE_DEFERRED = 2  # some constants, some settings deferred to wrapping plugin runtime
WRAPPING_TYPE_LAST = 3      # using last (current at runtime) settings of wrapped

# Other constants
PARAM_SEP = ", "

# Globals
substitutions = {}


def comma_separate(strings):
  '''
  Strategy for parameter separators: add to any parameter sequence that is not empty.
  A trailing comma in a parameter list doesn't hurt.
  Join separate parameter sequences without a comma, since they all have trailing commas.
  '''
  if strings:
    return PARAM_SEP.join(strings) + PARAM_SEP  # !!! Trailing
  else:
    return ""


def summarize():
  '''
  Return string describing  wrapping plugin we generated.
  !!! Assert substitutions created.
  '''
  return template.summarytemplate.substitute(substitutions)
  

def generate(plugin_spec):
  '''
  Generate file of python code for a Gimp plugin.
  Specified by plugin_spec.
  '''
  
  # !!! uniquify before generation
  plugin_spec.commands.param_list.uniquify_names()
  
  global substitutions
  substitutions = make_substitution_map(plugin_spec)
  
  # Substitute substitutions into  python template, creating a Python script.
  substitutedtemplate = template.wrappingtemplate.substitute(substitutions)
  
  # Write completed script to file.
  # TODO warn of overwrite
  #if os.path.isfile(filepath):
  filepath = substitutions["filepath"]
  with open(filepath, "w") as f:
    f.write(substitutedtemplate)
  
  # Make wrapping plugin file executable. (Linux, Mac OSX, not needed for Windows?)
  os.chmod(filepath, stat.S_IRWXU)



def make_substitution_map(plugin_spec):
  '''
  Create map for template substitution (actual parameters to  template.)
  !!! Note substitution map is used for more than one template.
  '''
  
  '''
  Make common substitution strings.
  '''
  # User's chosen name.  Author-user should choose a unique one, else there will be clashes.
  # Might not be clashes in  menus, but could be clashes in filenames and PDB procedure names.
  # !!! Translate spaces and other punctuation: delete them
  trans_menuitem = plugin_spec.wrapping.menuname.translate(None, ' .,?!:;()')
  
  # Formerly tried to include a name from  wrapped or its blurb, but its not easy
  # Gimp std + our wrapping std + author-user's wrapping name
  # Example PDB name: python-fu-foo-wraps-blur
  # Example filename: plugin-foo-wraps-blur
  # !!! include  author-user's chosen name so author-user can create many wrapping plugins to same wrapped.
  wrappingname = GIMPSCRIPTER_WRAP + trans_menuitem # EG -wrapper-foo
  # WAS item + "-" + GIMPSCRIPTER_WRAP + plugin_spec.wrapping.name
  wrappingprocedurename = GIMP_STD_PROCEDURENAME_PREFIX + wrappingname
  wrappingfilename = GIMP_STD_FILENAME_PREFIX + wrappingname

  substitutions = {}

  '''
  Make substitution strings for plugin_main() of wrapping plugin.
  '''
  commands = plugin_spec.commands
  
  substitutions["wrappingmainformalparams"] = make_wrapping_main_formal_params(commands)
  substitutions["wrappingmainbody"] = make_wrapping_main_body(commands)
  
  '''
  Make substitution strings for registering wrapping plugin.
  '''
  # Image type for  wrapping plugin that is same image type as  wrapped plugin.
  substitutions["wrappingimagetype"] = what_in_image_type(commands)
  # make standard name for  wrapping plugin procedure.
  # !!! Note this is a string, don't need to substitute underbars for dash
  substitutions["wrappingprocedurename"] = wrappingprocedurename
  # TODO let  author-user enter a blurb but default it to a reasonable guess
  substitutions["wrappingblurb"] = make_wrapping_blurb(commands)
  substitutions["wrappingparameterdefs"] = make_wrapping_paramdefs(commands)
  '''
  label and menu parameters work together.
  !!! A side effect of menu parameter is to omit image and drawable parameters to a plugin.
  !!! Obscure wierdness in gimpfu.
  Set them so that image and drawable parameters are passed to wrapping plugin,
  if wrapped plugin needs them.
  Otherwise gimpfu might open a dialog for image parameter in some circumstances.
  '''
  substitutions["wrappingmenupath"] = WRAPPING_MENU_PATH_PREFIX + "/" + plugin_spec.wrapping.menuname
  """
  if commands.is_take_image():
    # label comprises menu path cat menu item
    # menu keyword arg omitted
    # !!! gimpfu will pass image and drawable to wrapping plugin
    substitutions["wrappinglabel"] = substitutions["wrappingmenupath"]
    substitutions["wrappingmenuarg"] = ""
  else:
  """
  # label is just menu item
  # menu keyword is menupath
  # !!! gimpfu will NOT pass image and drawable to wrapping plugin
  substitutions["wrappinglabel"] = plugin_spec.wrapping.menuname
  substitutions["wrappingmenuarg"] = 'menu="' + WRAPPING_MENU_PATH_PREFIX_REGISTER + '"'
  
  if is_need_runtime(commands):
    filepath = gimp.directory + "/plug-ins/gimpscripter/runtime.py"
    with open(filepath, "r") as f:
      substitutions["wrappingruntimelibrary"] = f.read()
    substitutions["prelude"] = GIMPSCRIPTER_PRELUDE
    substitutions["postlude"] = GIMPSCRIPTER_POSTLUDE
  else:  # omit runtime
    substitutions["wrappingruntimelibrary"] = "" 
    substitutions["prelude"] = ""
    substitutions["postlude"] = ""
  
  # Make file path to local plugins.
  # Pygimp knows parent directory + standard directory name + filename + standard extension
  substitutions["filepath"] = gimp.directory + "/plug-ins/" + wrappingfilename + ".py"
  
  return substitutions


def what_in_image_type(commands):
  '''
  What is IN image type of a seq of commands?
  !!! first command defines it for all subsequent commands.
  A command may reduce image type (for example gimp-mode-greyscale.)
  Do we want to check these semantics?
  '''
  return plugindb.plugindb[commands.command_list[0].name].imagetype
  
  
def what_wrapping_type(command, wrappedparms):
  '''
  Return type of wrapping plugin being generated.
  Depends on author-user choices in parameter_dialog: whether LAST_VALS, and whether any parameters are deferred.
  !!! Note this is for a single command.
  '''
  if command.is_use_last:
    return WRAPPING_TYPE_LAST  
  else:
    if parameters.any_parms_deferred(wrappedparms):  # if any were deferred
      # A mix of author-user entered values, and names for deferred parameters.
      # !!! wrapping plugin will be INTERACTIVE, wrapped target will be NONINTERACTIVE
      return WRAPPING_TYPE_DEFERRED
    else:
      # All parameters constant. Both wrapping plugin and wrapped target will be NONINTERACTIVE, just "go"
      return WRAPPING_TYPE_CONSTANT
      

'''
These are decision routines.
'''
def is_need_runtime(commands):
  '''
  A runtime library is needed if:
  TODO update this comment
  - if wrapping has hidden params
  - if author-user did not defer (did enter name strings) for ephemeral parameters.
  Put library code into wrapping plugin, rather than import a module of library code, 
  so publishing a wrapping plugin is simpler (not dependent on other modules.)
  Alternatively, template should include "from gimpscripter import runtime"
  and EPHEMERAL_CALL should be "runtime.ephemeral.lookup"
  '''
  # TODO if all ephemeral are OUT params of wrapped plugins, no need for this
  ## WAS if commands.has_ephemeral_params() :
      
  # Temporarily, until we can figure out whether macros use ephemera,
  # return True
  return commands.has_ephemeral_params()


def is_need_wrapper_main_formal_param_image(commands):
  ''' Does wrapper need formal parameters "image, drawable" 
  If any command refers to "image" or "drawable" in leading params (what we call IN or hidden params)
  OR if needs runtime (since the runtime depends on image, drawable to initialize stacks.
  '''
  # WAS  is_take_image()
  return commands.has_in_params() or is_need_runtime(commands)
  

'''
These make_foo routines put together strings for substitution in a template of Python code
from various pieces of slices of Param for wrapped plugin.
'''


def make_wrapping_main_formal_params(commands):
  '''
  Return string for formal parameters of wrapping plugin main() procedure.
  Depends on whether wrapped commands take same parameters (which are passed through).
  Note names of hidden parameters (e.g. "image") must match between:
    wrapping main formal parameters 
    call to wrapped commands
  Any deferred wrapped parameters must also be parameters of wrapping.
  '''
  
  if is_need_wrapper_main_formal_param_image(commands):
    hidden_params = "image, drawable, " # !!! Trailing comma
  else:
    # Also, imagetypes param to register() should be empty,
    # meaning wrapped plugin is enabled always (whether an image is open or not.)
    hidden_params = ""
  return hidden_params + make_wrapping_formal_params_for_wrapped(commands)



def make_paramdef_default(parm):
  '''
  Returns a string (for use in generated code) that is a default value for a paramdef.
  
  For most types of parameters, author-user enters a value of same type e.g. integer.
  But for ephemeral types, author-user enters a value of a different type e.g. string.
  For ephemerals, make a None value, which is a value of all types.
  That forces wrapping-user to make another choice at wrapping plugin runtime i.e. it is intial value,
  but not really a default in the sense that it is acceptable.
  '''
  if parameters.is_ephemeral_type(parm.type):
    return "None"     # TODO should it be -1 since PyGimp translates -1 to None?
  else:
    return parm.get_evaluable_value() # repr() so a string type is quoted


def make_standard_paramdefs(commands):
  if is_need_wrapper_main_formal_param_image(commands):
    return '(PF_IMAGE, "image", "Input image", None), (PF_DRAWABLE, "drawable", "Input drawable", None)'
  else:
    return ""
    

def make_wrapping_paramdefs(commands):
  '''
  Return string of parameter definitions for wrapping plugin registration.
  These comprise:
    standard "image, drawable" hidden paramdefs if needed
    deferred parameters.
  They are made from wrapped param defs for deferred parameters.
  
  Note names must match between:
    wrapping main formal parameters
    wrapping paramdefs
    
  These will cause wrapping plugin to show a dialog at its runtime
  so wrapping-user can enter deferred parameters to be passed to wrapped plugins.
  
  Note that default values are missing from paramdefs (since PDB doesn't hold them.)
  Thus for default (remember, we are generating Python plugin code, which takes a default
  as 4th argument for a paramdef)
  For default value, use value author-user entered when deferring parameter.
  
  # TBD another options (range) parameter for certain types? SLIDERS
  '''
  wrappedparms = commands.param_list
  
  # Comma separated cat param defs, turned into strings
  paramdefstrings = []
  
  standard_paramdefs = make_standard_paramdefs(commands)
  if standard_paramdefs:
    paramdefstrings.append(standard_paramdefs)
    
  for parm in parameters.get_parms_deferred(wrappedparms):
    
    paramdefparts = [constantmaps._type_to_string_map[parm.type], # type: numeric => name of a constant
      # name and desc strings, need quotation, ie a string literal
      '"' + parm.unique_name + '"', # !!! unique_name
      '"' + parm.desc + '"',
      make_paramdef_default(parm) ] # The default. Is a string but not quoted unless it is string literal
    paramdefstring = "[" + PARAM_SEP.join(paramdefparts) + "]"  # Each paramdef is a list or tuple
    paramdefstrings.append(paramdefstring)

  return PARAM_SEP.join(paramdefstrings)



def make_wrapping_formal_params_for_wrapped(commands):
  '''
  Return comma separated string of names of formal parameters for wrapping plugin
  that must be passed so they can be put in call to wrapped.
  e.g. "tweak, tweak1, color"
  These :
    -are nonhidden formal parameters of wrapped plugin 
    -AND are deferred parameters
    -AND are unique within the string (and within the wrapper.)
  nondefered parameters don't need to pass through wrapping main,
  they are just constants in a call to wrapped.
  '''
  return comma_separate(commands.deferred_unique_names())


def make_wrapping_blurb(commands):
  '''
  Return blurb string for wrapping plugin.
  One of three types.
  '''
  suffix = ""
  return "blurb"  # TODO
  command = commands[0] # TODO aggregate
  wrapping_type = what_wrapping_type(command) # TODO this takes wrappingparms
  if wrapping_type == WRAPPING_TYPE_DEFERRED:
    suffix = " with a settings dialog at runtime."
  elif wrapping_type == WRAPPING_TYPE_CONSTANT:
    suffix = " with all settings constant."
  elif wrapping_type == WRAPPING_TYPE_LAST:
    suffix = " using it's latest settings."
  
  # If this is a simple shortcut wrapping ONE other,
  # a good blurb is "Wrapping menupathmap[command.name]
  return "A wrapping plugin" + suffix


def make_imagetype_string(procname):
  '''
  Return imagetype string eg. "RGB" for a plugin.
  '''
  return make_procname_to_imagetype_map()[procname]



def make_LHS_name(paramtype):
  if paramtype == PF_IMAGE:
    return "fooimage"
  else:
    return "fooobject"

def make_LHS_string(command):
  '''
  Make LHS (left hand side) for an assignment of a call to a procedure.
  !!! Note that few plugins don't have return values, but some do e.g. Offset Palette
  !!! Note LHS contains '=' (usual meaning of LHS does not)
  '''
  names = []
  for parm in parameters.get_return_parms(command.name):
    names.append(make_LHS_name(parm.type))
  if names:
    if len(names) > 1:
      return "(" + ",".join(names) + ") ="  # a tuple is returned from plugins unless a single value
    else:
      return names[0] + "="
  else:
    return ""
  
  
def make_wrapping_main_body(commands):
  ''' Generate seq of command invocations for body of wrapping plugin main. '''
  script = ""
  for position in range(0, len(commands)):
    script += make_invocation(commands, position)
  return script


def make_invocation(commands, position):
  ''' 
  Return Python code for an invocation  (call) of a command. 
  It may include lines of code before and after call.
  '''
  script = ""
  if commands.has_ephemeral_params() :
    # Each command must be preceded by because any prior command may have created ephemera
    # TODO we might be able to forego this, if we knew which commands created ephemera
    script += INTER_COMMAND_RUNTIME
  
  # Generate a comment that indicates what menu item was chosen by author-user
  script += "  # " + commands.get_command_for(position).pathstring + '\n'
  
  # Generate call
  script += "  "  # Indent to standard depth: two spaces.  Must match template.
  # Since two commands may have same name, get parms for them by position
  script += make_call_string(commands, position) # , commands.get_parms_for(position))
  script += '\n'  # trail newline.  Note this is platform independent, Python accepts all terminators.
  return script
  
  
def make_call_string(commands, position):
  '''
  Make Python code for a call to named procedure or macro, with parameters.
  !!! For internal procedure, plugin, or macro.  But there are subtle differences.
  
  Note that for a plugin,  in the PDB, the first three parameters are always run-mode, image, and drawable.
  But Pygimp requires run-mode as a keyword arg
  '''
  command = commands.get_command_for(position)
  parms = commands.get_parms_for(position)
  
  # transliterate _ => - in name
  # Because in Python, - is subtraction operator, can't be used in names.
  underbar_name = command.name.replace("-", "_")
  
  wrapping_type = what_wrapping_type(command, parms)
  
  if parse_params.has_runmode(parms):
    # PDB procedure of type Plugin except for those whose name begins with 'file-'
    if wrapping_type == WRAPPING_TYPE_LAST:
      run_mode_string = "run_mode=RUN_WITH_LAST_VALS"
    else:
      run_mode_string = "run_mode=RUN_NONINTERACTIVE"
  else: # PDB procedure of type Internal Procedure or a Plugin whose name begins with 'file-'
    run_mode_string = ""
  
  # TODO condense this and refactor into a subroutine
  if wrapping_type == WRAPPING_TYPE_DEFERRED:
    # A mix of author-user entered values, and names for deferred parameters.
    # !!! wrapping plugin will be INTERACTIVE, wrapped target will be NONINTERACTIVE
    paramstring = make_actual_nonhidden_params(parms) # WAS make_deferred_params(parms)
  elif wrapping_type == WRAPPING_TYPE_CONSTANT:
    # All settings passed as constants.
    # author-user saw, and optionally changed, settings when creating wrapping plugin.
    # Both wrapping plugin and wrapped target will be NONINTERACTIVE, just "go"
    paramstring = make_actual_nonhidden_params(parms) # WAS make_constant_actual_params(parms)
  elif wrapping_type == WRAPPING_TYPE_LAST:
    # Not Care parameters but tell wrapped to use last values.
    paramstring = make_NC_params(parms)
  else :
    raise RuntimeError, "Unknown wrapping type"

  if macros.is_macro(command.name):
    return generate_macro_call(command.name, parms)
  else:
    '''
    Generic form:  <LHS> = gimp.pdb.<NAME> ( <HIDDEN>, <PARMS>, run_mode=<MODE> )
    '''
    return make_LHS_string(command) \
      + PDB_INVOKE_PREFIX + underbar_name \
      + "( " + make_hidden_params(parms) \
      + paramstring \
      + run_mode_string \
      + ")"


def make_hidden_params(wrappedparms):
  '''
  Make a string of actual parameters for hidden parameters of a wrapped plugin.
  !!! Exclude run-mode
  '''
  # For each hidden param (excluding first, which is run_mode), map its type to string for canonical name.
  # tbd more to it, this is a trick, but not adequate?
  # tbd in future, it might be a reference to an earlier name returned from earlier step, ie stacked
  if parse_params.has_runmode(wrappedparms):
    start = 1
  else:
    start = 0
  return comma_separate([str(constantmaps._hidden_actual_map[parm.type]) for parm in parameters.get_parms_hidden(wrappedparms)[start:]])
  

def make_NC_params(wrappedparms):
  ''' For call to wrapped plugin, make a string of actual parameters with don't care values.'''
  params = []
  
  # !!!Note pygimp provides pdb[name].params attribute, a list of parameter definitions.
  # !!!Don't need to call gimp.pdb.gimp_procedural_db_proc_info(name)
  #
  # Omit first standard params: run-mode
  # image, drawable are in map:
  # They are mapped not to an instance, but to an actual parameter
  # that will be passed through from wrapping plugin to wrapped plugin.
  # TODO this is broke
  for paramdef in wrappedparms.nonhiddenparamdefs:
    paramtype = paramdef[0]
    # map param type to instance of type
    # !!! Note want str() not repr() so an "image" parameter is not quoted. TBD revisit this
    params.append(str(constantmaps._instance_map[paramtype]))
  return comma_separate(params)


def make_lookup(paramtype, name):
  '''
  Generate call to a wrapping plugin runtime routine to lookup an ephemeral object by name.
  E.g. "runtime.ephemera.lookup(PF_IMAGE, "foo")
  '''
  return EPHEMERAL_LOOKUP + "(" \
    + constantmaps._type_to_string_map[paramtype]  \
    + "," \
    + name \
    + ")"


def list_actual_nonhidden_params(parms):
  ''' 
  Return a list of strings for actual non-hidden params.
  Such a list can subsequently be substituted in macros, or comma separated.
  '''
  ''' 
  For call to wrapped plugin, make a string of actual parameter values.
  Where author-user, at creation time:
  - entered values, so constant at runtime (no dialog to wrapping-user.)
  - chose "Use current" for ephemeral types, so actual parameter is a reference to stack
  - did NOT chose "Use current" for ephemeral types, generate a runtime lookup of a constant name
  '''
  actual_params = []
  for parm in parameters.get_parms_nonhidden(parms):
    if parm.is_deferred:
      # deferred.  Could be ephemeral
      # wrapping will have this name as formal parameter.
      # wrapping will have a dialog to enter actual parameter.
      # wrapping will assign to this name at runtime.
      # wrapped will refer to this name in its actual parameters.
      actual = parm.unique_name   # !!!! unique
    elif parameters.is_ephemeral_type(parm.type):
      # not deferred but emphemeral
      actual = make_lookup(parm.type, parm.get_evaluable_value() )
    else:
      # not deferred and not ephemeral, a constant
      actual = parm.get_evaluable_value() # convert object to evaluable
    assert actual is not None, str(parm)
    actual_params.append(actual)
  return actual_params
  
  
# Was make_constant_actual_params
def make_actual_nonhidden_params(wrappedparms):
  ''' 
  Return a comma separated string of actual, nonhidden params.
  Such a string is part of actual parameters in a call string.
  '''
  return comma_separate(list_actual_nonhidden_params(wrappedparms))


def generate_macro_call(name, parms):
  ''' Generate a string that is Python code from our macros '''
  
  # Template for substitutions is text of macro declaration.
  template = macros.template_for(name)
  
  # Create substitutions for parameters of the macro.
  substitutions = {}
  # If author-user deferred parameter, substitute a unique object name (which will get a value at run-time)
  # else if author-user entered a constant value, substitute that
  # substitutions["channelName"] = '"foo"' # Test
  actual_params = list_actual_nonhidden_params(parms)
  i = 0
  for item in actual_params:
    # Note that actual params have uniquified names that no longer match placeholder name
    substitutions[parms[i].name] = str(item)
    i += 1
  
  # Return result string of substitutions
  try:
    result = template.substitute(substitutions)
  except ValueError as details:
    raise RuntimeError("Placeholders in GimpScripter macros must be valid Python identifiers" + str(details) )
  except KeyError as details:
    raise RuntimeError("Missing substitute for a placeholder in a GimpScripter macro" + str(details) )
  print "Macro result is", result
  return result
  
  
"""
def make_deferred_params(wrappedparms):
  ''' 
  For a call to a procedure, make string of actual parameters (args) which is a mix of:
    -actual values the author-user entered (constants or strings that name ephemerals)
    -names of deferred parameters
  '''
  params = []
  for i in range(0,len(wrappedparms.userentered)):
    if wrappedparms.defers[i]:
      # Argument is name of deferred parameter, which matches
      # name of a formal parameter to wrapping plugin.
      # Wrapping-user will see dialog to enter it at wrapping plugin runtime.
      params.append(wrappedparms.nonhiddennames[i])
    else:
      params.append(wrappedparms.userentered[i])
  return comma_separate(params)
"""

'''
  These are three test instances: python, scheme, C.  
  To prove that LAST_VALS ignores parameters, etc.
  !!! Note, must pass all parameters, even if LAST_VALS means ignore them
  # pdb.plug_in_resynthesizer2(timg, tdrawable, 0,0, 1, tdrawable, -1, -1, 0.0, 0.117, 16, 500, run_mode=RUN_WITH_LAST_VALS)
  # pdb.script_fu_add_bevel(timg, tdrawable, 5.0, 0, 0, run_mode=RUN_WITH_LAST_VALS)
  # pdb.plug_in_nova(timg, tdrawable, 0,0,(10,10,10),0, 0, 0, run_mode=RUN_WITH_LAST_VALS)
'''




